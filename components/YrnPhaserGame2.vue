<i18n lang="yaml">
  ar:
    defineCarMoves: "ÙŠØ­Ø¯Ø¯ Ø§Ù„ØªØ³Ù„Ø³Ù„ Ø§Ù„Ø¶Ø±ÙˆØ±ÙŠ Ù„Ù„Ø­Ø±ÙƒØ§Øª Ù„Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ù…Ø­Ø·Ø© Ø§Ù„Ø´Ø­Ù†."
    executeSequenceOfMoves: "ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ³Ù„Ø³Ù„"
    resetBtn: "Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†"
    resetBtnCar: "Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ù…ÙˆØ¶Ø¹ Ø§Ù„Ø³ÙŠØ§Ø±Ø© Ø§Ù„Ø£ØµÙ„ÙŠ"
    resetBtnMoves: "Ù…Ø³Ø­ Ø§Ù„ØªØ³Ù„Ø³Ù„ Ø§Ù„Ø­Ø§Ù„ÙŠ Ù„Ù„Ø­Ø±ÙƒØ§Øª"
  ca:
    defineCarMoves: "Defineix la seqÃ¼Ã¨ncia de moviments necessaris per arribar a l'estaciÃ³ de cÃ rrega."
    executeSequenceOfMoves: "Executa la seqÃ¼Ã¨ncia"
    resetBtn: "Reiniciar"
    resetBtnCar: "Restaurar la posiciÃ³ inicial del cotxe"
    resetBtnMoves: "Esborrar la seqÃ¼Ã¨ncia de moviments actual"
  de:
    defineCarMoves: "Definiert die Sequenz der Bewegungen, die notwendig sind, um die Ladestation zu erreichen."
    executeSequenceOfMoves: "Ablauffolge ausfÃ¼hren"
    resetBtn: "ZurÃ¼cksetzen"
    resetBtnCar: "Setzt die ursprÃ¼ngliche Position des Autos zurÃ¼ck"
    resetBtnMoves: "LÃ¶sche die aktuelle Bewegungssequenz"
  en:
    defineCarMoves: "Defines the sequence of movements necessary to reach the charging station."
    executeSequenceOfMoves: "Run sequence"
    resetBtn: "Reset"
    resetBtnCar: "Reset car's initial position"
    resetBtnMoves: "Clear current sequence of moves"
  es:
    defineCarMoves: "Define la secuencia de movimientos necesarios para llegar a la estaciÃ³n de carga."
    executeSequenceOfMoves: "Ejecutar secuencia"
    resetBtn: "Reiniciar"
    resetBtnCar: "Restablece la posiciÃ³n inicial del coche"
    resetBtnMoves: "Borrar la secuencia de movimientos actual"
  eu:
    defineCarMoves: "Zeharrekinen sekuentzia definitzen du karga-geltokira iristeko."
    executeSequenceOfMoves: "Exekutatu sekuentzia"
    resetBtn: "Berrezarri"
    resetBtnCar: "Automobilaren lehenengo posizioa berrezarri"
    resetBtnMoves: "Garapen-sekuentzia egungo ezabatu"
  fr:
    defineCarMoves: "DÃ©finit la sÃ©quence des mouvements nÃ©cessaires pour atteindre la station de charge."
    executeSequenceOfMoves: "ExÃ©cuter la sÃ©quence"
    resetBtn: "RÃ©initialiser"
    resetBtnCar: "RÃ©initialiser la position initiale de la voiture"
    resetBtnMoves: "Effacer la sÃ©quence de mouvements actuelle"
  it:
    defineCarMoves: "Definisce la sequenza di movimenti necessari per raggiungere la stazione di ricarica."
    executeSequenceOfMoves: "Esegui la sequenza"
    resetBtn: "Reset"
    resetBtnCar: "Ripristina la posizione iniziale dell'auto"
    resetBtnMoves: "Cancella la sequenza di movimenti attuale"
  ja:
    defineCarMoves: "å……é›»ã‚¹ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã«åˆ°é”ã™ã‚‹ãŸã‚ã«å¿…è¦ãªå‹•ãã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’å®šç¾©ã—ã¾ã™ã€‚"
    executeSequenceOfMoves: "å‹•ãã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’å®Ÿè¡Œ"
    resetBtn: "ãƒªã‚»ãƒƒãƒˆ"
    resetBtnCar: "è»Šã®åˆæœŸä½ç½®ã‚’ãƒªã‚»ãƒƒãƒˆ"
    resetBtnMoves: "ç¾åœ¨ã®å‹•ãã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’æ¶ˆå»"
  pt:
    defineCarMoves: "Define a sequÃªncia de movimentos necessÃ¡rios para chegar Ã  estaÃ§Ã£o de carregamento."
    executeSequenceOfMoves: "Executar seqÃ¼Ãªncia"
    resetBtn: "Redefinir"
    resetBtnCar: "Redefinir posiÃ§Ã£o inicial do carro"
    resetBtnMoves: "Limpar sequÃªncia atual de movimentos"
  ro:
    defineCarMoves: "DefineÈ™te secvenÈ›a de miÈ™cÄƒri necesare pentru a ajunge la staÈ›ia de Ã®ncÄƒrcare."
    executeSequenceOfMoves: "Executa secvenÈ›a"
    resetBtn: "Resetare"
    resetBtnCar: "ResetaÈ›i poziÈ›ia iniÈ›ialÄƒ a maÈ™inii"
    resetBtnMoves: "È˜tergeÈ›i secvenÈ›a actualÄƒ de miÈ™cÄƒri"
  ru:
    defineCarMoves: "ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµÑ‚ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ Ğ´Ğ²Ğ¸Ğ¶ĞµĞ½Ğ¸Ğ¹, Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ñ‹Ñ… Ğ´Ğ»Ñ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ¶ĞµĞ½Ğ¸Ñ Ğ·Ğ°Ñ€ÑĞ´Ğ½Ğ¾Ğ¹ ÑÑ‚Ğ°Ğ½Ñ†Ğ¸Ğ¸."
    executeSequenceOfMoves: "ĞŸĞ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ Ğ·Ğ°Ğ¿ÑƒÑĞºĞ°"
    resetBtn: "Ğ¡Ğ±Ñ€Ğ¾Ñ"
    resetBtnCar: "Ğ¡Ğ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ Ğ½Ğ°Ñ‡Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ¿Ğ¾Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¼Ğ°ÑˆĞ¸Ğ½Ñ‹"
    resetBtnMoves: "ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ Ğ´Ğ²Ğ¸Ğ¶ĞµĞ½Ğ¸Ğ¹"
  zh:
    defineCarMoves: "å®šä¹‰åˆ°è¾¾å……ç”µç«™æ‰€éœ€çš„è¿åŠ¨åºåˆ—ã€‚"
    executeSequenceOfMoves: "è¿è¡Œé¡ºåº"
    resetBtn: "é‡ç½®"
    resetBtnCar: "é‡ç½®æ±½è½¦çš„åˆå§‹ä½ç½®"
    resetBtnMoves: "æ¸…é™¤å½“å‰ç§»åŠ¨åºåˆ—"
</i18n>

<template>
  <v-container class="yrn-phaser-game" fluid>
    <v-row>
      <v-col>
        <h2>
          {{ $t('defineCarMoves') }}
        </h2>
      </v-col>
    </v-row>
    <v-row class="mt-2 overflow-hidden">
      <v-col
        xl="6"
        lg="6"
        md="6"
        sm="12"
        xs="12"
        cols="12"
        class="overflow-y-auto"
        :order="$vuetify.breakpoint.mdAndUp ? 'last' : 'first'"
        :style="`max-height: calc(100vh - ${$vuetify.breakpoint.mdAndUp ? 64 + 8 : 56 + 8}px);`"
      >
        <yrn-drag-and-drop-with-two-lists
          ref="dragAndDropComponent"
          :draggable-items-title="draggableItemsTitle"
          :drop-area-title="dropAreaTitle"
          :items="gameUIButtons"
          visible-property="title"
        >
          <template #bottom>
            <v-row>
              <v-col class="d-flex justify-center">
                <v-menu
                  top
                  close-on-content-click
                >
                  <template #activator="{ on, attrs }">
                    <v-btn
                      block
                      color="deep-orange"
                      x-large
                      v-bind="attrs"
                      v-on="on"
                    >
                      {{ $t('resetBtn') }}
                    </v-btn>
                  </template>
                  <v-list>
                    <v-list-item @click="resetCarPosition()">
                      <v-list-item-title>
                        {{ $t('resetBtnCar') }}
                      </v-list-item-title>
                    </v-list-item>
                    <v-list-item @click="resetMoveSequence()">
                      <v-list-item-title>
                        {{ $t('resetBtnMoves') }}
                      </v-list-item-title>
                    </v-list-item>
                  </v-list>
                </v-menu>
              </v-col>
              <v-col class="d-flex justify-center">
                <v-btn
                  block
                  color="primary"
                  x-large
                  @click="executeSequenceOfMoves()"
                >
                  <v-icon class="mr-2">
                    mdi-play
                  </v-icon>
                  {{ $t('executeSequenceOfMoves') }}
                </v-btn>
              </v-col>
            </v-row>
          </template>
        </yrn-drag-and-drop-with-two-lists>
      </v-col>
      <v-col
        xl="6"
        lg="6"
        md="6"
        sm="12"
        xs="12"
        cols="12"
      >
        <div id="phaserContainer" />
      </v-col>
    </v-row>
  </v-container>
</template>

<script>
import * as Phaser from 'phaser'

export default {
  name: 'YrnPhaserGame',
  props: {
    customBoard: {
      default: null,
      required: false,
      type: Array
    },
    maxMoves: {
      default: -1,
      required: true,
      type: Number
    },
    numCols: {
      default: 7,
      required: false,
      type: Number
    },
    numRows: {
      default: 5,
      required: false,
      type: Number
    },
    useDefaultMovement: {
      default: true,
      required: false,
      type: Boolean
    }
  },
  data() {
    return {
      board: [],
      batteryLevel: 100,
      batteryLevelText: null,
      batteryText: null,
      car: null,
      carBatteryIndicator: null,
      carColor: 'Red',
      carDirections: {
        north: 'NORTH',
        east: 'EAST',
        south: 'SOUTH',
        west: 'WEST'
      },
      carModel: 'COUPE',
      config: {
        autoRound: false,
        fps: {
          target: 30,
          forceSetTimeOut: true
        },
        height: 520,
        parent: 'phaserContainer',
        physics: {
          default: 'arcade',
          arcade: {
            gravity: { y: 200 }
          }
        },
        scale: {
          parent: 'phaserContainer',
          mode: Phaser.Scale.WIDTH_CONTROLS_HEIGHT
        },
        scene: [],
        type: Phaser.AUTO,
        width: 640
      },
      currentTile: {
        spriteDirection: 'SOUTH',
        x: 1,
        y: 0 
      },
      draggableItemsTitle: {
        ar: ':Ø§Ù„ØªÙ†Ù‚Ù„Ø§Øª Ø§Ù„Ù…ØªÙˆÙØ±Ø©',
        ca: 'Moviments disponibles:',
        de: 'VerfÃ¼gbare Bewegungen:',
        en: 'Available moves:',
        es: 'Movimientos disponibles:',
        eu: 'Jakinarazpenak eskura:',
        fr: 'DÃ©placements disponibles:',
        gl: 'Movementos dispoÃ±Ã­beis:',
        it: 'Spostamenti disponibili:',
        ja: 'ä½¿ç”¨å¯èƒ½ãªç§»å‹•:',
        pt: 'Movimentos disponÃ­veis:',
        ru: 'Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ´Ğ²Ğ¸Ğ¶ĞµĞ½Ğ¸Ñ:',
        zh: 'å¯ç”¨ç§»åŠ¨ï¼š'
      },
      dropAreaTitle: {
        ar: ':Ø§Ù„ØªÙ†Ù‚Ù„Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©',
        ca: 'Moviments necessaris:',
        de: 'BenÃ¶tigte Bewegungen:',
        en: 'Required moves:',
        es: 'Movimientos necesarios:',
        eu: 'Ezabakizunak behar duenak:',
        fr: 'DÃ©placements nÃ©cessaires:',
        gl: 'Movementos necesarios:',
        it: 'Spostamenti necessari:',
        ja: 'å¿…è¦ãªç§»å‹•:',
        pt: 'Movimentos necessÃ¡rios:',
        ru: 'ĞĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ñ‹Ğµ Ğ´Ğ²Ğ¸Ğ¶ĞµĞ½Ğ¸Ñ:',
        zh: 'æ‰€éœ€ç§»åŠ¨ï¼š'
      },
      game: null,
      gameDone: false,
      gameUIButtons: [
        // Populated on the `created` hook
      ],
      isMoving: false,
      keyboardEventCodes: {
        arrowUp: 'ArrowUp',
        arrowDown: 'ArrowDown',
        arrowLeft: 'ArrowLeft',
        arrowRight: 'ArrowRight'
      },
      moveTween: null,
      moveQueue: [],
      movementsUsed: 0,
      offsetX: 20,
      offsetY: 22,
      propsByKeyboardEventCodes: {
        customMoves: {
          // Populated on the `created` hook
        },
        defaultMoves: {
          // Populated on the `created` hook
        }
      },
      textureKeys: {
        carPathEnd: 'timanfaya_texture',
        minecraftDeepFloor: 'minecraft_deep_floor_texture',
        sceneBackground: 'scene_background_texture'
      },
      tileSize: 120,
      usedBatteryIndicator: null
    }
  },
  computed: {
    carReachedLastPosition() {
      // Obtiene las coordenadas del coche en tÃ©rminos de la matriz de caminos
      const carColumn = Math.floor(this.car.x / this.tileSize)
      const carRow = Math.floor(this.car.y / this.tileSize)

      // Verifica si el coche estÃ¡ en la Ãºltima fila y Ãºltima columna de la matriz
      return carColumn === this.numCols - 1 && carRow === this.numRows - 1
    }
  },
  created() {
    this.gameUIButtons = [
      {
        icon: 'mdi-alpha-a-circle',
        nodeIndex: 'A',
        title: {
          ar: "Ø¹Ù‚Ø¯Ø© A",
          ca: "Node A",
          de: "Knoten A",
          en: "Node A",
          es: "Nodo A",
          eu: "Node A",
          fr: "Noeud A",
          gl: "Nodo A",
          it: "Nodo A",
          ja: "ãƒãƒ¼ãƒ‰ A",
          pt: "NÃ³ A",
          ro: "Nod A",
          ru: "Ğ£Ğ·ĞµĞ» A",
          zh: "èŠ‚ç‚¹ A"
        },
        "xAxisIndex": 1,
        "yAxisIndex": 0
      },
      {
        icon: 'mdi-alpha-b-circle',
        nodeIndex: 'B',
        title: {
          ar: "Ø¹Ù‚Ø¯Ø© B",
          ca: "Node B",
          de: "Knoten B",
          en: "Node B",
          es: "Nodo B",
          eu: "Node B",
          fr: "Noeud B",
          gl: "Nodo B",
          it: "Nodo B",
          ja: "ãƒãƒ¼ãƒ‰ B",
          pt: "NÃ³ B",
          ro: "Nod B",
          ru: "Ğ£Ğ·ĞµĞ» B",
          zh: "èŠ‚ç‚¹ B"
        },
        "xAxisIndex": 2,
        "yAxisIndex": 0
      },
      {
        icon: 'mdi-alpha-c-circle',
        nodeIndex: 'C',
        title: {
          ar: "Ø¹Ù‚Ø¯Ø© C",
          ca: "Node C",
          de: "Knoten C",
          en: "Node C",
          es: "Nodo C",
          eu: "Node C",
          fr: "Noeud C",
          gl: "Nodo C",
          it: "Nodo C",
          ja: "ãƒãƒ¼ãƒ‰ C",
          pt: "NÃ³ C",
          ro: "Nod C",
          ru: "Ğ£Ğ·ĞµĞ» C",
          zh: "èŠ‚ç‚¹ C"
        },
        "xAxisIndex": 0,
        "yAxisIndex": 1
      },
      {
        icon: 'mdi-alpha-d-circle',
        nodeIndex: 'D',
        title: {
          ar: "Ø¹Ù‚Ø¯Ø© D",
          ca: "Node D",
          de: "Knoten D",
          en: "Node D",
          es: "Nodo D",
          eu: "Node D",
          fr: "Noeud D",
          gl: "Nodo D",
          it: "Nodo D",
          ja: "ãƒãƒ¼ãƒ‰ D",
          pt: "NÃ³ D",
          ro: "Nod D",
          ru: "Ğ£Ğ·ĞµĞ» D",
          zh: "èŠ‚ç‚¹ D"
        },
        "xAxisIndex": 1,
        "yAxisIndex": 1
      },
      {
        icon: 'mdi-alpha-e-circle',
        nodeIndex: 'E',
        title: {
          ar: "Ø¹Ù‚Ø¯Ø© E",
          ca: "Node E",
          de: "Knoten E",
          en: "Node E",
          es: "Nodo E",
          eu: "Node E",
          fr: "Noeud E",
          gl: "Nodo E",
          it: "Nodo E",
          ja: "ãƒãƒ¼ãƒ‰ E",
          pt: "NÃ³ E",
          ro: "Nod E",
          ru: "Ğ£Ğ·ĞµĞ» E",
          zh: "èŠ‚ç‚¹ E"
        },
        "xAxisIndex": 2,
        "yAxisIndex": 1
      },
      {
        icon: 'mdi-alpha-f-circle',
        nodeIndex: 'F',
        title: {
          ar: "Ø¹Ù‚Ø¯Ø© F",
          ca: "Node F",
          de: "Knoten F",
          en: "Node F",
          es: "Nodo F",
          eu: "Node F",
          fr: "Noeud F",
          gl: "Nodo F",
          it: "Nodo F",
          ja: "ãƒãƒ¼ãƒ‰ F",
          pt: "NÃ³ F",
          ro: "Nod F",
          ru: "Ğ£Ğ·ĞµĞ» F",
          zh: "èŠ‚ç‚¹ F"
        },
        "xAxisIndex": 1,
        "yAxisIndex": 2
      },
      {
        icon: 'mdi-alpha-g-circle',
        nodeIndex: 'G',
        title: {
          ar: "Ø¹Ù‚Ø¯Ø© G",
          ca: "Node G",
          de: "Knoten G",
          en: "Node G",
          es: "Nodo G",
          eu: "Node G",
          fr: "Noeud G",
          gl: "Nodo G",
          it: "Nodo G",
          ja: "ãƒãƒ¼ãƒ‰ G",
          pt: "NÃ³ G",
          ro: "Nod G",
          ru: "Ğ£Ğ·ĞµĞ» G",
          zh: "èŠ‚ç‚¹ G"
        },
        "xAxisIndex": 2,
        "yAxisIndex": 2
      },
      {
        icon: 'mdi-alpha-h-circle',
        nodeIndex: 'H',
        title: {
          ar: "Ø¹Ù‚Ø¯Ø© H",
          ca: "Node H",
          de: "Knoten H",
          en: "Node H",
          es: "Nodo H",
          eu: "Node H",
          fr: "Noeud H",
          gl: "Nodo H",
          it: "Nodo H",
          ja: "ãƒãƒ¼ãƒ‰ H",
          pt: "NÃ³ H",
          ro: "Nod H",
          ru: "Ğ£Ğ·ĞµĞ» H",
          zh: "èŠ‚ç‚¹ H"
        },
        "xAxisIndex": 3,
        "yAxisIndex": 1
      },
      {
        icon: 'mdi-alpha-i-circle',
        nodeIndex: 'I',
        title: {
          ar: "Ø¹Ù‚Ø¯Ø© I",
          ca: "Node I",
          de: "Knoten I",
          en: "Node I",
          es: "Nodo I",
          eu: "Node I",
          fr: "Noeud I",
          gl: "Nodo I",
          it: "Nodo I",
          ja: "ãƒãƒ¼ãƒ‰ I",
          pt: "NÃ³ I",
          ro: "Nod I",
          ru: "Ğ£Ğ·ĞµĞ» I",
          zh: "èŠ‚ç‚¹ I"
        },
        "xAxisIndex": 2,
        "yAxisIndex": 3
      },
      {
        icon: 'mdi-alpha-j-circle',
        nodeIndex: 'J',
        title: {
          ar: "Ø¹Ù‚Ø¯Ø© J",
          ca: "Node J",
          de: "Knoten J",
          en: "Node J",
          es: "Nodo J",
          eu: "Node J",
          fr: "Noeud J",
          gl: "Nodo J",
          it: "Nodo J",
          ja: "ãƒãƒ¼ãƒ‰ J",
          pt: "NÃ³ J",
          ro: "Nod J",
          ru: "Ğ£Ğ·ĞµĞ» J",
          zh: "èŠ‚ç‚¹ J"
        },
        "xAxisIndex": 3,
        "yAxisIndex": 2
      }
    ]

    this.propsByKeyboardEventCodes.customMoves = {
      [this.keyboardEventCodes.arrowUp]: {
      },
      [this.keyboardEventCodes.arrowDown]: {
      },
      [this.keyboardEventCodes.arrowLeft]: {
        carDirection: this.carDirections.west
      },
      [this.keyboardEventCodes.arrowRight]: {
        carDirection: this.carDirections.east
      }
    }
    this.propsByKeyboardEventCodes.defaultMoves = {
      [this.keyboardEventCodes.arrowUp]: {
        deltaRowIndex: -1,
        deltaColumnIndex: 0,
        carDirection: this.carDirections.north
      },
      [this.keyboardEventCodes.arrowDown]: {
        deltaRowIndex: 1,
        deltaColumnIndex: 0,
        carDirection: this.carDirections.south
      },
      [this.keyboardEventCodes.arrowLeft]: {
        deltaRowIndex: 0,
        deltaColumnIndex: -1,
        carDirection: this.carDirections.west
      },
      [this.keyboardEventCodes.arrowRight]: {
        deltaRowIndex: 0,
        deltaColumnIndex: 1,
        carDirection: this.carDirections.east
      }
    }
    if (Array.isArray(this.customBoard)) {
      this.board = this.customBoard
    } else {
      do {
        this.board = this.createBoard({ numRows: this.numRows, numCols: this.numCols })
      } while(this.checkIfPathExists() === false)
    }
  },
  mounted() {
    this.initPhaserGame()
  },
  methods: {
    addBackgroundImage(scene, backgroundTexture = this.textureKeys.sceneBackground) {
      const { width, height } = scene.sys.game.canvas
      const backgroundImage = scene.add.image(width / 2, height / 2, backgroundTexture)
      const scaleX = width / backgroundImage.width
      const scaleY = height / backgroundImage.height
      const scale = Math.max(scaleX, scaleY)
      backgroundImage.setOrigin(0.5, 0.5).setScale(scale).setDepth(-2)
    },
    addPhaserBoard(scene, offsetX = this.offsetX, offsetY = this.offsetY) {
      const cellSize = this.tileSize
      const squareSize = cellSize - (((56 * 100) / this.tileSize) * this.tileSize) / 100
      const lastRowIndex = this.board.length - 1
      const lastColumnIndex = this.board[0].length - 1
      const lineWidth = squareSize

      this.board.forEach((row, rowIndex) => {
        row.forEach((element, columnIndex) => {
          const posX = columnIndex * cellSize + cellSize / 2 + offsetX
          const posY = rowIndex * cellSize + cellSize / 2 + offsetY
          const textStyle = {
            align: 'center',
            fontFamily: 'MartelSans, monospace'
          }

          this.drawPhaserSquare(scene, posX, posY, squareSize)
          if (element.nodeIndex.length === 1) {
            textStyle.color = '#ffffff'
            textStyle.fontSize = '24px'
            this.addPhaserText(scene, posX, posY, element.nodeIndex, textStyle)
          } else {
            textStyle.color = '#03ff00'
            textStyle.fontSize = '18px'
            this.addPhaserText(scene, posX, posY, element.nodeIndexWeight, textStyle)
          }

          // Dibujar conexiones con elementos adyacentes
          if (element.down) {
            this.drawPhaserLine(
              scene,
              posX,
              posY + squareSize / 2,
              posX,
              posY + cellSize - squareSize / 2,
              lineWidth
            )
            if (element.downIsHalfPath === undefined) {
              const textX = posX - 2
              const textY = posY + cellSize / 2 - 2 // En la mitad de la lÃ­nea vertical
              scene
                .add
                .text(textX, textY, element.down.toString(), { fontSize: '18px', fill: '#03ff00' })
                .setDepth(Number.MAX_SAFE_INTEGER - 1)
                .setOrigin(0.5)
            }
          }
          if (element.right) {
            this.drawPhaserLine(
              scene,
              posX + squareSize / 2,
              posY,
              posX + cellSize - squareSize / 2,
              posY,
              lineWidth
            )
            if (element.rightIsHalfPath === undefined) {
              const textX = posX + cellSize / 2 - 2 // En la mitad de la lÃ­nea horizontal
              const textY = posY + 2
              scene
                .add
                .text(textX, textY, element.right.toString(), { fontSize: '18px', fill: '#03ff00' })
                .setDepth(Number.MAX_SAFE_INTEGER - 1)
                .setOrigin(0.5)
            }
          }
          if (element.up) {
            this.drawPhaserLine(
              scene,
              posX,
              posY - squareSize / 2,
              posX,
              posY - cellSize + squareSize / 2,
              lineWidth
            )
          }
          if (element.left) {
            this.drawPhaserLine(
              scene,
              posX - squareSize / 2,
              posY,
              posX - cellSize + squareSize / 2,
              posY,
              lineWidth
            )
          }

          if (rowIndex === lastRowIndex - 2 && columnIndex === lastColumnIndex) {
            const endOfPathX = posX + this.offsetX / 2
            const endOfPathY = posY + this.tileSize / 3
            this.addPhaserPathEndImage(scene, endOfPathX, endOfPathY)
          }
        })
      })
    },
    addPhaserCar(scene, offsetX = this.offsetX, offsetY = this.offsetY) {
      try {
        this.car = scene.add.sprite(
          this.tileSize * 2 - this.tileSize / 2 + offsetX,
          this.tileSize / 2 + offsetY,
          `car_spritesheet_${this.currentTile.spriteDirection}`
        )
        this.car
          .setDepth(Number.MAX_SAFE_INTEGER)
          .setOrigin(0.5)
          .setScale(1.5)
          .play(`car_animation_${this.currentTile.spriteDirection}`)
      } catch (error) {
        console.error('Error adding car to scene: %o', error)
      }
    },
    addPhaserCarBatteryIndicator(scene = this.config.scene[0]) {
      const marginTop = 50
      const marginRight = 30
      const indicatorWidth = 60
      const indicatorHeight = scene.sys.game.canvas.height - 140
      const batteryTextHeight = 25
      const textStyle = {
        color: '#ffffff',
        fontSize: '13px',
        align: 'center',
        fontFamily: 'MartelSans, monospace'
      }

      // AÃ±adir el rectÃ¡ngulo indicador de baterÃ­a
      if (!this.carBatteryIndicator) {
        this.carBatteryIndicator = scene.add.graphics()
        this.carBatteryIndicator.fillStyle(0x00ff00)
        this.carBatteryIndicator.fillRect(
          scene.sys.game.canvas.width - indicatorWidth - marginRight,
          marginTop,
          indicatorWidth,
          indicatorHeight
        )
      }

      // AÃ±adir el texto "BATTERY"
      if (!this.batteryText) {
        this.batteryText = scene.add.text(
          scene.sys.game.canvas.width - indicatorWidth - marginRight,
          marginTop + indicatorHeight + 10,
          'BATTERY',
          textStyle
        )
        this.batteryText.setOrigin(0)
      }

      // AÃ±adir el porcentaje de baterÃ­a con carga
      textStyle.fontSize = '20px'
      this.batteryLevelText = scene.add.text(
        scene.sys.game.canvas.width - indicatorWidth - marginRight,
        marginTop + indicatorHeight + batteryTextHeight,
        `${this.getBatteryLevel()}%`,
        textStyle
      )
      this.batteryLevelText.setOrigin(0)
    },
    addPhaserPathEndImage(
      scene,
      posX,
      posY,
      offsetX = this.offsetX,
      offsetY = this.offsetY,
      textureKey = this.textureKeys.carPathEnd
    ) {
      this.carPathEnd = scene.add.image(
        posX + offsetX,
        posY + offsetY,
        textureKey
      )
      this.carPathEnd.setOrigin(0, 0)
      this.carPathEnd.setDepth(Number.MAX_SAFE_INTEGER - 1)
    },
    addPhaserKeyboardInput(scene) {
      let propsByKeyboardEventCodes
      if (this.useDefaultMovement) {
        propsByKeyboardEventCodes = this.propsByKeyboardEventCodes.defaultMoves
      } else {
        propsByKeyboardEventCodes = this.propsByKeyboardEventCodes.customMoves
      }

      scene.input.keyboard.on('keydown', (event) => {
        if (this.isMoving) { return }
        const propsByKeyboardEventCode = propsByKeyboardEventCodes[event.code]
        if (propsByKeyboardEventCode) {
          const { deltaColumnIndex, deltaRowIndex, carDirection } = propsByKeyboardEventCode
          this.movePhaserCar(event.code, carDirection, deltaColumnIndex, deltaRowIndex)
        }
      })
    },
    addPhaserText(scene, posX, posY, text, textStyle) {
      // AÃ±adir el texto en el centro del elemento
      scene.add.text(posX, posY, text, textStyle).setOrigin(0.5)
    },
    animateBatteryLevelText(scene = this.config.scene[0]) {
      // Asegura que el objeto text ya estÃ© creado y listo para ser actualizado.
      if (!this.batteryLevelText) {
        console.error('Battery level text has not been initialized.')
        return
      }

      // Crea un objeto auxiliar para la animaciÃ³n
      const batteryData = { level: 0 }

      // Crea el tween para animar este objeto auxiliar
      scene.tweens.add({
        targets: batteryData,
        level: 100,
        duration: 5000,
        ease: 'Cubic.easeInOut',
        onUpdate: () => {
          // Actualiza el texto del objeto text cada vez que cambia la propiedad level
          this.batteryLevelText.setText(`${Math.floor(batteryData.level)}%`)
        }
      })
    },
    changeCarSprite(direction) {
      const newSpriteSheet = `/img/phaserjs/top-down-vehicles/${this.carModel}/` +
        `${this.carColor}/MOVE/${direction}/${this.carColor}_${this.carModel}` +
        `_CLEAN_${direction}_000-sheet.png`
      this.car.anims.stop()
      this.car.setTexture(newSpriteSheet)
      this.car.play(`car_animation_${direction}`)
      this.$set(this.currentTile, 'spriteDirection', direction)
    },
    /**
     * Checks if a move is valid in the game board.
     * It only checks if the move is within the boundaries of the board.
     * It only checks the move between the current position on the matrix.
     * Optionally, it also checks if the distance trying to move is not greater
     * than one position.
     *
     * @param {number} fromRowIndex - The starting row index of the move.
     * @param {number} fromColumnIndex - The starting column index of the move.
     * @param {number} toRowIndex - The target row index of the move.
     * @param {number} toColumnIndex - The target column index of the move.
     * @param {string} direction - The direction of the move.
     * @return {boolean} Returns true if the move is valid, false otherwise.
     */
    checkMove(fromRowIndex, fromColumnIndex, toRowIndex, toColumnIndex, direction, checkDistance = false) {
      console.log("ğŸš€ ~ checkMove ~ direction:", direction)
      // Check if the coordinates are out of the board boundaries
      if (
        fromRowIndex < 0 ||
        fromColumnIndex < 0 ||
        fromRowIndex >= this.board.length ||
        fromColumnIndex >= this.board[0].length ||
        toRowIndex < 0 ||
        toColumnIndex < 0 ||
        toRowIndex >= this.board.length ||
        toColumnIndex >= this.board[0].length
      ) {
        return false
      }

      // Check if the distance between fromRowIndex and toRowIndex is just 1 or not
      // or if the distance between fromColumnIndex and toColumnIndex is just 1 or not.
      let isValidDistance = true

      if (checkDistance) {
        isValidDistance =
          Math.abs(toRowIndex - fromRowIndex) <= 1 &&
          Math.abs(toColumnIndex - fromColumnIndex) <= 1
        console.log("ğŸš€ ~ checkMove ~ isValidDistance:", isValidDistance)
      }

      const currentElement = this.board[fromRowIndex][fromColumnIndex]
      const targetElement = this.board[toRowIndex][toColumnIndex]

      switch (direction) {
        case this.carDirections.south:
          return (currentElement.down || targetElement.up) &&
            toRowIndex > fromRowIndex &&
            isValidDistance
        case this.carDirections.west:
          return (currentElement.left || targetElement.right) &&
            toColumnIndex < fromColumnIndex &&
            isValidDistance
        case this.carDirections.north:
          return (currentElement.up || targetElement.down) &&
            toRowIndex < fromRowIndex &&
            isValidDistance
        case this.carDirections.east:
          return (currentElement.right || targetElement.left) &&
            toColumnIndex > fromColumnIndex &&
            isValidDistance
        default:
          return false
      }
    },
    createBoard({ numRows, numCols, maxWeight } = {}) {
      numRows = numRows ?? this.$getRandomInt(3, 5)
      numCols = numCols ?? this.$getRandomInt(3, 7)
      maxWeight = maxWeight ?? this.$getRandomInt(3, 10)

      return Array.from({ length: numRows }, (_, rowIndex) => {
        return Array.from({ length: numCols }, (_, columnIndex) => {
          return this.createBoardElement(rowIndex, columnIndex, numRows, numCols)
        })
      })
    },
    createBoardElement(rowIndex, columnIndex, numRows, numCols) {
      // Determinar si existe, un elemento en la matriz,
      // adyacente en cada direcciÃ³n.
      const up = rowIndex > 0 ? this.$getRandomBoolean() : false
      const down = rowIndex < numRows - 1 ? this.$getRandomBoolean() : false
      const left = columnIndex > 0 ? this.$getRandomBoolean() : false
      const right = columnIndex < numCols - 1 ? this.$getRandomBoolean() : false
      const setWeightHelper = (condition) => {
        return condition ? this.$getRandomInt(1, 10) : 0
      }

      const weightUp = setWeightHelper(up)
      const weightDown = setWeightHelper(down)
      const weightLeft = setWeightHelper(left)
      const weightRight = setWeightHelper(right)

      return {
        up,
        down,
        left,
        right,
        weightUp,
        weightDown,
        weightLeft,
        weightRight,
        rowIndex: this.$castIndexToCharacter(rowIndex, true),
        columnIndex: this.$castIndexToCharacter(columnIndex, true)
      }
    },
    checkIfPathExists() {
      const numRows = this.board.length
      const numCols = this.board[0].length

      // Creamos una matriz de visitados inicialmente llena de falsos
      const visited = new Array(numRows).fill(false).map(() => new Array(numCols).fill(false))

      // Definimos una funciÃ³n recursiva para buscar el camino
      const dfs = (row, col) => {
        // Si estamos fuera de los lÃ­mites de la matriz o ya hemos visitado esta celda, retornamos false
        if (row < 0 || row >= numRows || col < 0 || col >= numCols || visited[row][col]) {
          return false
        }

        // Marcamos esta celda como visitada
        visited[row][col] = true

        // Si estamos en la Ãºltima celda, retornamos true
        if (row === numRows - 1 && col === numCols - 1) {
          return true
        }

        // Verificamos si podemos movernos hacia abajo, arriba, derecha o izquierda
        const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]
        for (const [dr, dc] of directions) {
          const newRow = row + dr
          const newCol = col + dc
          if (dfs(newRow, newCol)) {
            return true
          }
        }

        // Si no encontramos un camino vÃ¡lido, marcamos esta celda como no visitada para futuras exploraciones
        visited[row][col] = false

        return false
      }

      // Iniciamos la bÃºsqueda desde la celda [0,0]
      return dfs(0, 0)
    },
    customPhaserCarMove(
      deltaRowIndex = 0,
      deltaColumnIndex = 0,
      keyDirection,
      carDirection,
      offsetX = this.offsetX,
      offsetY = this.offsetY
    ) {
      carDirection = carDirection ?? this.currentTile.spriteDirection
      const scene = this.config.scene[0]
      let currentRow = this.currentTile.y
      const prevRow = currentRow
      let currentCol = this.currentTile.x
      const prevCol = currentCol

      // Si se presiona la flecha hacia abajo, no hacer nada
      if (keyDirection === this.keyboardEventCodes.arrowDown) {
        return
      }

      // Si se presiona la flecha hacia arriba, mover el coche en la direcciÃ³n del sprite actual
      if (keyDirection === this.keyboardEventCodes.arrowUp) {
        const directionKeyMap = {
          'NORTH': this.keyboardEventCodes.arrowUp,
          'SOUTH': this.keyboardEventCodes.arrowDown,
          'EAST': this.keyboardEventCodes.arrowRight,
          'WEST': this.keyboardEventCodes.arrowLeft
        }
        switch (this.currentTile.spriteDirection) {
          case this.carDirections.north:
            deltaRowIndex = -1
            deltaColumnIndex = 0
            break
          case this.carDirections.south:
            deltaRowIndex = 1
            deltaColumnIndex = 0
            break
          case this.carDirections.east:
            deltaRowIndex = 0
            deltaColumnIndex = 1
            break
          case this.carDirections.west:
            deltaRowIndex = 0
            deltaColumnIndex = -1
            break
          default:
            console.error(`Unknown sprite direction: ${this.currentTile.spriteDirection}`)
            deltaRowIndex = 0
            deltaColumnIndex = 0
        }

        // Se mueve en la direcciÃ³n especificada hasta que ya no sea posible
        while (this.checkMove(
          currentRow,
          currentCol,
          currentRow + deltaRowIndex,
          currentCol + deltaColumnIndex,
          // Obten la tecla correspondiente a la direcciÃ³n de la animaciÃ³n,
          // para comprobar si puede moverse en dicha direcciÃ³n
          directionKeyMap[carDirection]
        )) {
          currentRow += deltaRowIndex
          currentCol += deltaColumnIndex
        }
      } else {
        this.turnPhaserCar(keyDirection, carDirection)
      }

      const moveDuration = 500 * Math.max(
        Math.abs(currentCol - this.currentTile.x),
        Math.abs(currentRow - this.currentTile.y)
      )

      const targetY = currentRow * this.tileSize + this.tileSize / 2 + this.offsetY
      const targetX = currentCol * this.tileSize + this.tileSize / 2 + this.offsetX

      this.currentTile.y = currentRow
      this.currentTile.x = currentCol
      this.isMoving = true

      if (this.moveTween) {
        this.moveTween.stop()
      }

      this.moveTween = scene.tweens.add({
        targets: this.car,
        y: targetY,
        x: targetX,
        duration: moveDuration,
        ease: 'Linear',
        onComplete: () => {
          this.isMoving = false
          this.moveTween = null
          if (
            keyDirection === this.keyboardEventCodes.arrowUp && (
              currentCol !== prevCol ||
              currentRow !== prevRow)
          ) {
            this.updatePhaserCarBatteryIndicator(true)
          }
          this.executeNextMove()
        }
      })
    },
    /**
     * Moves the default Phaser car in the specified direction.
     *
     * @param {number} deltaRowIndex - The change in row index.
     * @param {number} deltaColumnIndex - The change in column index.
     * @param {string} direction - The direction of movement.
     * @param {string} carDirection - The direction of the car sprite.
     * @return {void}
     */
    defaultPhaserCarMove(deltaRowIndex, deltaColumnIndex, direction, carDirection) {
      console.log("ğŸš€ ~ defaultPhaserCarMove")
      const scene = this.config.scene[0]
      const newColumnIndex = this.currentTile.x + deltaColumnIndex
      const newRowIndex = this.currentTile.y + deltaRowIndex

      if (this.isDiagonalMove(deltaRowIndex, deltaColumnIndex)) {
        console.warn('Movimiento no vÃ¡lido, no se puede mover en diagonal')
        return
      }

      const canMove = this.checkMove(
        this.currentTile.y,
        this.currentTile.x,
        newRowIndex,
        newColumnIndex,
        carDirection,
        true
      )
      console.log("ğŸš€ ~ defaultPhaserCarMove ~ canMove:", canMove)
      const moveCost = this.getMoveCost(this.currentTile.y, this.currentTile.x, carDirection)
      console.log("ğŸš€ ~ defaultPhaserCarMove ~ moveCost:", moveCost)

      if (canMove) {
        const targetX = newColumnIndex * this.tileSize + this.tileSize / 2 + this.offsetX
        const targetY = newRowIndex * this.tileSize + this.tileSize / 2 + (this.offsetY / 2)
        this.currentTile.x = newColumnIndex
        this.currentTile.y = newRowIndex
        this.isMoving = true

        if (this.moveTween) {
          this.moveTween.stop()
        }

        this.changeCarSprite(carDirection)

        this.moveTween = scene.tweens.add({
          targets: this.car,
          x: targetX,
          y: targetY,
          duration: 500,
          ease: 'Linear',
          onComplete: () => {
            this.isMoving = false
            this.moveTween = null
            if (direction === this.keyboardEventCodes.arrowUp) {
              this.updatePhaserCarBatteryIndicator(true, moveCost)
            }
            this.executeNextMove()
          }
        })
      }
    },
    drawPhaserLine(scene, startX, startY, endX, endY, lineWidth, textureKey = this.textureKeys.minecraftDeepFloor) {
      const deltaX = endX - startX
      const deltaY = endY - startY
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY)
      const angle = Math.atan2(deltaY, deltaX)
      const line = scene.add.tileSprite(
        (startX + endX) / 2,
        (startY + endY) / 2,
        distance,
        lineWidth,
        textureKey
      )

      line.setOrigin(0.5, 0.5)
      line.rotation = angle
    },
    drawPhaserSquare(scene, posX, posY, squareSize, textureKey = this.textureKeys.minecraftDeepFloor) {
      const square = scene.add.tileSprite(posX, posY, squareSize, squareSize, textureKey)
      square.setDepth(-1) // Asegurarse de que el sprite estÃ© detrÃ¡s de otros elementos
    },
    executeNextMove() {
      console.log("ğŸš€ ~ executeNextMove")
      if (this.movementsUsed < this.maxMoves) {
        if (this.moveQueue.length > 0) {
          const nextMove = this.moveQueue.shift()
          const keyboardDirection = this.keyboardEventCodes.arrowUp
          const carDirection = this.getCarDirectionFromMove(nextMove)
          console.log("ğŸš€ ~ executeNextMove ~ carDirection:", carDirection)
          const { xAxisIndex, yAxisIndex } = nextMove
          const deltaRowIndex = yAxisIndex - this.currentTile.y
          console.log("ğŸš€ ~ executeNextMove ~ deltaRowIndex:", deltaRowIndex)
          const deltaColumnIndex = xAxisIndex - this.currentTile.x
          console.log("ğŸš€ ~ executeNextMove ~ deltaColumnIndex:", deltaColumnIndex)

          this.movePhaserCar(keyboardDirection, carDirection, deltaRowIndex, deltaColumnIndex)
        }
      }
    },
    executeSequenceOfMoves() {
      console.log("ğŸš€ ~ executeSequenceOfMoves")
      const dragAndDropComponent = this.$refs.dragAndDropComponent

      if (dragAndDropComponent && dragAndDropComponent.list2) {
        const phaserCarMoves = dragAndDropComponent.list2

        // Agregar cada movimiento a la cola
        this.moveQueue = phaserCarMoves.map(move => ({
          name: move.nodeIndex,
          xAxisIndex: move.xAxisIndex,
          yAxisIndex: move.yAxisIndex
        }))
        console.log("ğŸš€ ~ executeSequenceOfMoves ~ this.moveQueue:", this.moveQueue)

        this.executeNextMove()
      } else {
        console.error("Error: No se pudo obtener list2 desde YrnDragAndDropWithTwoLists")
      }
    },
    fillPhaserCarBatteryIndicator(scene = this.config.scene[0]) {
      this.animateBatteryLevelText()
      scene.tweens.add({
        targets: this.usedBatteryIndicator,
        scaleY: 0,
        duration: 5000,
        ease: 'Cubic.easeInOut'
      })
    },
    getBatteryLevel() {
      const percentageUsed = Math.min(100, (this.movementsUsed / this.maxMoves) * 100)
      return window?.Math?.floor(100 - percentageUsed)
    },
    getCarDirectionFromMove(move) {
      let carDirection = ''

      if (this.currentTile.x < move.xAxisIndex) {
        carDirection = this.carDirections.east
      } else if (this.currentTile.x > move.xAxisIndex) {
        carDirection = this.carDirections.west
      } else if (this.currentTile.y < move.yAxisIndex) {
        carDirection = this.carDirections.south
      } else if (this.currentTile.y > move.yAxisIndex) {
        carDirection = this.carDirections.north
      }

      return carDirection
    },
    getMoveCost(currentTileY, currentTileX, carDirection) {
      const carPosition = this.board[currentTileY][currentTileX]
      switch (carDirection) {
        case this.carDirections.south:
          return carPosition.down
        case this.carDirections.west:
          return carPosition.left
        case this.carDirections.north:
          return carPosition.up
        case this.carDirections.east:
          return carPosition.right
        default:
          return 0
      }
    },
    initPhaserGame() {
      const gameScene = new Phaser.Scene('GameScene')

      gameScene.preload = () => {
        // Preload de la textura
        gameScene.load.image(this.textureKeys.carPathEnd, '/img/phaserjs/parque-naciona-timanfaya/128x128/diablo-timanfaya.png')
        // gameScene.load.image(this.textureKeys.carPathEnd, '/img/phaserjs/parque-naciona-timanfaya/128x128/diablo-timanfaya-en-el-parque-nacional-1.png')
        gameScene.load.image(this.textureKeys.minecraftDeepFloor, '/img/phaserjs/textures/100x100/minecraft-deep-floor.jpg')
        gameScene.load.image(this.textureKeys.sceneBackground, '/img/phaserjs/backgrounds/main.jpg')

        Object.values(this.carDirections).forEach((direction) => {
          gameScene.load.spritesheet(
            `car_spritesheet_${direction}`,
            `/img/phaserjs/top-down-vehicles/${this.carModel}/${this.carColor}/` +
            `MOVE/${direction}/${this.carColor}_${this.carModel}` +
            `_CLEAN_${direction}_000-sheet.png`, {
            frameWidth: 100,
            frameHeight: 100
          }
          )
        })
      }

      gameScene.create = () => {
        const totalFrames = 12
        const frameRate = 12

        Object.values(this.carDirections).forEach((direction) => {
          gameScene.anims.create({
            key: `car_animation_${direction}`,
            frames: gameScene.anims.generateFrameNumbers(
              `car_spritesheet_${direction}`, {
              start: 0,
              end: totalFrames - 1,
              first: 0
            }
            ),
            frameRate,
            repeat: -1 // repite la animaciÃ³n indefinidamente
          })
        })

        this.addBackgroundImage(gameScene)
        this.addPhaserBoard(gameScene)
        this.addPhaserCar(gameScene)
        this.addPhaserCarBatteryIndicator(gameScene)
        // Keyboard game controls disabled, by default, the user must define a
        // sequence of movements to finally execute them all one after another.
        // this.addPhaserKeyboardInput(gameScene)
      }
      this.config.scene.push(gameScene)
      this.game = new Phaser.Game(this.config)
    },
    isDiagonalMove(deltaRowIndex, deltaColumnIndex) {
      // Si el movimiento es diagonal, devuelve true
      return !(Math.abs(deltaRowIndex) + Math.abs(deltaColumnIndex) === 1)
    },
    movePhaserCar(keyboardDirection, carDirection, deltaRowIndex = null, deltaColumnIndex = null) {
      console.log("ğŸš€ ~ movePhaserCar")
      if (this.useDefaultMovement) {
        this.defaultPhaserCarMove(deltaRowIndex, deltaColumnIndex, keyboardDirection, carDirection)
      } else {
        this.customPhaserCarMove(deltaRowIndex, deltaColumnIndex, keyboardDirection, carDirection)
      }
    },
    resetCarPosition() {
      // Restablecer la posiciÃ³n del coche
      if (this.car) {
        const posX = this.tileSize * 2 - this.tileSize / 2 + this.offsetX
        const posY = this.tileSize / 2 + this.offsetY

        this.car.setPosition(posX, posY)
        this.changeCarSprite(this.carDirections.south)
        this.currentTile = {
          spriteDirection: 'SOUTH',
          x: 1,
          y: 0
        }
        this.gameDone = false
        this.movementsUsed = 0
        this.makePhaserElementBlink(this.car)
        this.updatePhaserCarBatteryIndicator()
      }
    },
    resetGame() {
      // Restablecer el juego
      this.resetMoveSequence()
      this.resetCarPosition()
      this.updatePhaserCarBatteryIndicator()
      this.gameDone = false
      this.movementsUsed = 0
    },
    resetMoveSequence() {
      // Restablecer la secuencia de movimientos
      this.$refs.dragAndDropComponent.resetList2()
    },
    turnPhaserCar(keyDirection) {
      const currentIndex = Object.values(this.carDirections).indexOf(this.currentTile.spriteDirection)
      let nextIndex
      if (keyDirection === this.keyboardEventCodes.arrowRight) {
        nextIndex = currentIndex + 1
        if (nextIndex === Object.keys(this.carDirections).length) {
          nextIndex = 0
        }
      } else if (keyDirection === this.keyboardEventCodes.arrowLeft) {
        nextIndex = currentIndex - 1
        if (nextIndex === -1) {
          nextIndex = Object.keys(this.carDirections).length - 1
        }
      }
      const nextDirection = Object.keys(this.carDirections)[nextIndex]
      this.changeCarSprite(this.carDirections[nextDirection])
    },
    updatePhaserCarBatteryIndicator(updateNumOfMoves = false, movementsUsed = 0, scene = this.config.scene[0]) {
      const marginTop = 50
      const marginRight = 30
      const indicatorWidth = 60

      // Definir la posiciÃ³n y dimensiones iniciales del rectÃ¡ngulo
      const positionX = scene.sys.game.canvas.width - indicatorWidth - marginRight
      const positionY = marginTop
      const initialHeight = scene.sys.game.canvas.height - 140
      const currentBatteryLevel = this.getBatteryLevel()

      if (updateNumOfMoves) {
        this.movementsUsed += movementsUsed
        const maxTargetHeight = 1
        const targetHeight = Math.min(((this.movementsUsed * 100) / this.maxMoves) / 100, maxTargetHeight)
        console.log("ğŸš€ ~ updatePhaserCarBatteryIndicator ~ targetHeight:", targetHeight)

        // Crear un grÃ¡fico si no existe
        if (!this.usedBatteryIndicator) {
          this.usedBatteryIndicator = scene.add.graphics()
            .setAlpha(0)
            .setPosition(positionX, positionY)
            .setDepth(Number.MAX_SAFE_INTEGER)
            .fillStyle(0xff0000, 1)
            .fillRect(0, 0, indicatorWidth, initialHeight)
        }

        // AnimaciÃ³n para cambiar la altura del rectÃ¡ngulo
        scene.tweens.add({
          targets: this.usedBatteryIndicator,
          scaleY: targetHeight,
          duration: 500,
          ease: 'Power1',
          onComplete: () => {
            if (currentBatteryLevel === 100) { 
              this.makePhaserElementBlink(this.usedBatteryIndicator)
            }
          }
        })
      } else {
        // Si no hay actualizaciÃ³n, destruir el texto de nivel de baterÃ­a
        // y agregar el indicador de baterÃ­a.
        this.batteryLevelText.destroy()
        if (this.usedBatteryIndicator) {
          this.usedBatteryIndicator.destroy()
          this.usedBatteryIndicator = null
        }
        this.addPhaserCarBatteryIndicator()
      }

      // Actualizar el texto del nivel de baterÃ­a
      this.batteryLevelText.setText(`${this.getBatteryLevel()}%`)

      // Si el coche alcanza la Ãºltima posiciÃ³n final, mostrar un mensaje de exito
      if (this.carReachedLastPosition) {
        this.gameDone = true
        // Implementar el cÃ³digo para el TODO comentario
        scene.time.delayedCall(2000, () => {
          this.fillPhaserCarBatteryIndicator(scene)
          this.$store?.dispatch('snackbarNotification/show', {
            i18n: this.$i18n,
            memojiName: 'director-bien',
            success: true
          })
        })
      } else if (this.movementsUsed >= this.maxMoves) {
        this.makePhaserElementBlink(this.car, 10, scene, () => {
          this.resetGame()
        })
        this.$store?.dispatch('snackbarNotification/show', {
          i18n: this.$i18n,
          memojiName: 'director-mal',
          success: false,
          defaultTextKey: 'batteryDown'
        })
      }
    },
    makePhaserElementBlink(target, numOfBlinks = 10, scene = this.config.scene[0], onCompleteCallback = null) {
      if (target) { 
        target.alpha = 1
        // Add a tween to make the target element to blink
        for (let i = 0; i < numOfBlinks; i++) {
          scene.tweens.add({
            alpha: 0,
            duration: 250,
            ease: 'Linear',
            repeat: 1,
            targets: target,
            yoyo: true,
            onComplete: () => {
              if (typeof onCompleteCallback === 'function') {
                onCompleteCallback()
              }
            }
          })
        }
      }
    }
  }
}
</script>
